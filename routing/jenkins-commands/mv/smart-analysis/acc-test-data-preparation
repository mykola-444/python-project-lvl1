#!/usr/bin/env bash
set -xe

# Check mandatory variables
source map-integration-testing/ci/routing/common_functions.sh
exit_if_no_env_var MAP_FORMAT
exit_if_no_env_var GET_TEST_RESULTS_BUILD_NUMBER
set_env_var_if_not_set ARTIFACT_DIR "output/artifacts"
set_env_var_if_not_set INPUT_DIR "input/${MAP_FORMAT}/test_routing_component"
set_env_var_if_not_set PYTHONPATH "/workspace/map-integration-testing:/workspace/map-integration-testing/ci/routing"
create_dir_if_not_exists "output/failed_keywords"

# Unpack parent job artifacts
tar -xvf results.tgz && job_builds=$(ls ${ARTIFACT_DIR}/*_builds.txt)

if [[ ${MAP_FORMAT} == "F8" ]]; then
    MAP_CONFIG="map_format8.config"
    # Read Map Config file
    source ${WORKSPACE}/map-config/${MAP_CONFIG}
    MAP_VERSION=${map_version}
    MAP_BUCKET=${map_aws_s3_bucket_url}
    MAP_OBJECT_KEY=${file_world_cdt}
    MAP_PATH=${map_path}
elif [[ ${MAP_FORMAT} == "BRF" ]]; then
    # Read BRF Config file
    BRF_CONFIG="map_format8_brf.config"
    source ${WORKSPACE}/map-config/${BRF_CONFIG}
    MAP_VERSION=${map_version}
    BRF_VERSION=${brf_compiler_version}
    MAP_BUCKET=${map_aws_s3_bucket_url}
    MAP_OBJECT_KEY=${folder_routing_server_brf}
else
    echo "ERROR: Unsupported MAP_FORMAT: ${MAP_FORMAT}"
    exit 1
fi

get_build_job_url() {
    test_job_url=${1%/*}; test_job_build=${1##*/}
    regex='Copied ([[:digit:]]) artifact from "(\w+) » (\w+) » (\w+) » (.*)" build number ([[:digit:]]+).*artifacts=\((.*gz)\)'
    for line in "$(curl $1/consoleText/${JENKINS_JSON_API_SUFFIX})"; do
        if [[ "${line}" =~ ${regex} ]]; then
            amount_artifacts="${BASH_REMATCH[1]}"; program_name="${BASH_REMATCH[2]}"
            stage="${BASH_REMATCH[3]}"; job_type="${BASH_REMATCH[4]}"
            job_name="${BASH_REMATCH[5]}"; build_number="${BASH_REMATCH[6]}"
            artifact_path="${BASH_REMATCH[7]}"
        fi
    done
    echo "INFO: Jenkins test job ($1) used [${amount_artifacts}] artifact from [${job_type}] type [${job_name}] job with build number [${build_number}] on path [${artifact_path}]"
    base_test_url=${test_job_url%%/team-*}; base_build_url=${base_test_url//test/$job_type}
    build_job_url="${base_build_url}/${job_name}"
    echo "INFO: Build job url: ${build_job_url} with build number: [${build_number}] will be used for further processing"
}

get_test_routing_component() {
    job_url=${1}; job_build=${2}; output_path=${3}; artifact_path=${4}
    echo "INFO: Trying to get test routing component from [${job_build}] build of ${job_url} Jenkins build job"
    wget -nc -v --tries=3 --timeout=120 -P "${output_path}/${job_build}" \
                                           "${job_url}"/"${job_build}"/s3/download/${artifact_path}
}

# Docker preparation
source_docker_cfg map-integration-testing/ci/routing/docker_acc.cfg
docker pull ${MITF_IMAGE} && exception_docker "${BUILD_TAG}"

while IFS= read -r job_build
    do
        echo "INFO: Getting parent build job information of ${job_build}"
        job_url=${job_build%/*}; failed_build_number=${job_build##*/}; project=${job_url##*/}
        get_build_job_url ${job_build}  &&
        get_test_routing_component ${build_job_url} ${build_number} ${INPUT_DIR} ${artifact_path}
        # Unpack the build component artifact
        test ! -d test_routing_component && mkdir test_routing_component
        tar xf ${output_path}/${job_build}/${artifact_path##*/} --directory test_routing_component
        # Get keywords from the failed test cases of the given jobs
        # Docker execution to find related failed acceptance tests
        docker run --env=REPORT="${ARTIFACT_DIR}/${test_job_build}/xunit.xml" \
                   --env=PYTHONPATH="${PYTHONPATH}" \
                   --interactive \
                   --name="${BUILD_TAG}" \
                   --rm \
                   --user="bldadmin" \
                   --volume="${WORKSPACE}:/workspace" \
                   --workdir="/workspace" \
                   ${MITF_IMAGE} bash -esux << "EOS"
                   python3 map-integration-testing/ci/routing/acceptance/failed_mitf_tests.py -r ${REPORT} \
                                                                                              -s test_routing_component/share/here/routing/spec/international;
EOS

        if [[ ! -e ./failed_keywords.txt ]]; then
            echo "WARN: There are not related to MITF failed Acceptance tests. Exiting ..."
        else
            mv "failed_keywords.txt" "output/failed_keywords/${project}_${failed_build_number}_failed_keywords.txt"
            echo ${project} >> "failed_jenkins_projects.txt"
        fi

done < ${job_builds}

awk 'FNR==1{f=1} /\) ;/{f=0} f' output/failed_keywords/*.txt > 'failed_keywords.txt'
FAILED_KEYWORDS=$(sort -u failed_keywords.txt | tr '\n' ';') && FAILED_KEYWORDS=${FAILED_KEYWORDS%;}
echo "INFO: Gathered FAILED_KEYWORDS [${FAILED_KEYWORDS}]"

LIBS=./libs && mkdir -p ${LIBS};

# Docker execution to find related failed acceptance tests
docker run --env=REPORT="${ARTIFACT_DIR}/${test_job_build}/xunit.xml" \
           --env=MITF_PATH="/workspace/map-integration-testing" \
           --env=FAILED_KEYWORDS="${FAILED_KEYWORDS}" \
           --env=ARTIFACT_DIR="${ARTIFACT_DIR}" \
           --env=PYTHONPATH="${PYTHONPATH}" \
           --env=MAP_FORMAT="${MAP_FORMAT}" \
           --env=LIBS="${LIBS}" \
           --interactive \
           --name="${BUILD_TAG}" \
           --rm \
           --user="bldadmin" \
           --volume="${WORKSPACE}:/workspace" \
           --workdir="/workspace" \
           ${MITF_IMAGE} bash -esux << "EOS"
           python3 map-integration-testing/ci/routing/acceptance/download_libs.py --map_config /workspace/map-config/map_format8.config \
                                                                                  --path_to_libs ${LIBS};
           echo "INFO: Updating tests using downloaded dumps";
           python3 map-integration-testing/ci/routing/acceptance/preprocess_libs.py -p ${LIBS} \
                                                                                    -o /workspace/test_libs \
                                                                                    -k "${FAILED_KEYWORDS}";
           # Check if merged lib files exist
           for file in output/test_libs/*; do
               [[ -e "${file}" ]] && echo "INFO: At least one ("${file}") merged lib exists" ||
               echo "ERROR: No one merged lib exist. Exiting ... "; exit 1;
               break
            done
           ./map-integration-testing/ci/routing/acceptance/update_acc_tests.sh

EOS

if [[ -n ${FAILED_KEYWORDS} ]]; then
    if [[ ${MAP_FORMAT} == "BRF" ]]; then
        aws s3 cp ${WORKSPACE}/robot_specs.tgz s3://${MITF_ARTIFACTS_BUCKET}/mitf/acc/updated/${MAP_FORMAT}_${MAP_VERSION}_${BRF_VERSION}/
        aws s3 cp ${WORKSPACE}/failed_jenkins_projects.txt s3://${MITF_ARTIFACTS_BUCKET}/mitf/acc/test_results/${MAP_FORMAT}_${MAP_VERSION}_${BRF_VERSION}/jenkins_projects.txt &&
        aws s3api put-object-acl \
                --bucket ${MITF_ARTIFACTS_BUCKET} \
                --key mitf/acc/test_results/${MAP_FORMAT}_${MAP_VERSION}_${BRF_VERSION}/jenkins_projects.txt \
                --grant-full-control ${MITF_AWS_S3_GRANTS}

    else
        aws s3 cp ${WORKSPACE}/robot_specs.tgz s3://${MITF_ARTIFACTS_BUCKET}/mitf/acc/updated/${MAP_FORMAT}_${MAP_VERSION}/
    fi
    aws s3api put-object-acl \
                --bucket ${MITF_ARTIFACTS_BUCKET} \
                --key mitf/acc/${MAP_FORMAT}_${MAP_VERSION}/robot_specs.tgz \
                --grant-full-control ${MITF_AWS_S3_GRANTS}
fi

